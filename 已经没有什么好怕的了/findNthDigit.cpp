/*
Day2
剑指 Offer 44. 数字序列中某一位的数字

数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。
请写一个函数，求任意第n位对应的数字。

示例 1：
输入：n = 3
输出：3

示例 2：
输入：n = 11
输出：0 

限制：
0 <= n < 2^31
*/

/*
思路
*/

#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

class Solution {
public:
	int findNthDigit(int n) {
		//首先n < 10，直接返回本身
		if (n < 10) {
			return n;
		}
		//然后，需要先定位
		//以n = 17为例，应该返回3
		//012345678910111213
		//一步步来，先确定是哪个数字，再确定是哪一位
		//首先，n=17，这个数字肯定大于9，可以直观的看出是小于20的，为什么？
		//0-9占10个，10-19占20个，也就是说，1位数占10个，2位数占90个，3位数占900个，4位数9000个，以此类推
		//0-9的特殊情况正好排除掉了，n<9直接返回n就好
		//那么在已知这个结论的情况下，n=17，可以快速定位到是一个两位数，而且是第两位数序列的第八个位，因为是两位数，所以是第四个两位数，10 11 12 13
		//定位到了13，因为是整除的，所以是第二位，所以是3
		//把这个思路抽象为代码
		//首先需要知道这个n在哪个区间

		//0-9，共有10个数，10个位，10 - 99，共有90个数，180个位，100 - 999，共900个数，2700个位，1000 - 9999，共9000个数，36000个位

		//举例，120，在两位数的区间，而且是两位数序列的第（120 - 10）=110个位，因为是2位数，所以是第55个两位数，是65，整除，是第一位，所以是6
		//举例，1232，在三位数区间，因为10 + 180《1232《10 + 180 + 2700，是三位数序列的第（1232-190）=1042个位，因为是3位数，所以是第347个（余1）三位数，447，第二位，是4
		//验证无误

		//我会做了
		//上一个解法忽略了位数，只在考虑数值

		//冷静
		int i = 2;
		//这个变量用于迭代i位数的个数
		long num_bound = 90;
		//这个变量用于迭代i位数最多有多少个位
		long cur_bound = 190;
		//记录i-1位数最多有多少个位
		int i_base = 10;
		while (n > cur_bound) {
			i_base = cur_bound;
			num_bound *= 10;
			++i;
			cur_bound += num_bound * i;
		}
		//找到了是i位数序列的第find_pos位
		int find_pos = n - i_base;
		//找到了是第find_num_pos个i位数
		int find_num_pos = find_pos / i;
		//求取余数
		int target_num_set_off = find_pos % i;
		int target_num = pow(10, i - 1) + find_num_pos;
		string target_num_str = to_string(target_num);
		return target_num_str[target_num_set_off] - '0';
	}
};

int main() {

}
