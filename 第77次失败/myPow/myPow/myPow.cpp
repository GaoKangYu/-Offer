/*
剑指 Offer 16. 数值的整数次方

实现 pow(x, n) ，即计算 x 的 n 次幂函数（即，x^n）。不得使用库函数，同时不需要考虑大数问题。

示例 1：
输入：x = 2.00000, n = 10
输出：1024.00000

示例 2：
输入：x = 2.10000, n = 3
输出：9.26100

示例 3：
输入：x = 2.00000, n = -2
输出：0.25000
解释：2^-2 = 1/2^2 = 1/4 = 0.25
 
提示：
-100.0 < x < 100.0
-2^31 <= n <= 2^31-1
-10^4 <= x^n <= 10^4
*/

/*
最简单的方法是O(n)的做法，也就是全部连乘，但是这样会超时

新知识点，快速幂

通常思路为：
for(int i = 0; i<n;++i){
	x *=_x;
}
会超时

如果利用中间值，比如，计算x^8，可以等价为x^2*x^2*x^2*x^2，这样就只需要计算4次（算x^2，再乘三个它）

所以可利用快速幂求解
n的二进制位一定是若干个1和0构成
9 = 1001 = 1*2^3 + 0*2^2 + 0*2^1 + 1*2^0
x^9 = x^(2^3) * x^(2^2 * 0) * x^(2^1 * 0) * x^(2^0)
*/

#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
	double myPow(double x, int n) {
		//边界条件，防止出现除数为0的情况
		if (x == 0) {
			return 0;
		}
		//返回值，中间变量
		double res = 1;
		//n可取值-2^31，取反为2^31，大于int取值（-2^31 ~ 2^31 - 1）
		long num = n;
		//正负是一样的，预处理
		if (num < 0) {
			x = 1 / x;
			num = -num;
		}
		//核心部分，快速幂是对幂进行处理，不是对底数
		while (num) {
			//幂的这一位是1
			if (num & 1) {
				//9 = 1001 = 1*2^3 + 0*2^2 + 0*2^1 + 1*2^0
				//x ^ 9 = x ^ (2 ^ 3) * x ^ (2 ^ 2 * 0) * x ^ (2 ^ 1 * 0) * x ^ (2 ^ 0)
				//那么添加到结果中
				//第一步相当于1*x*2^0
				res *= x;
			}
			//高位乘数是低位乘数的平方
			x *= x;
			//右移，除以2，继续判断下一个位
			num >>= 1;
		}
		//妙啊
		return res;
	}

	void acm() {
		int test_nums;
		cin >> test_nums;
		while (test_nums){
			int x, n;
			cin >> x >> n;
			cout << myPow(x, n) << endl;
			--test_nums;
		}
	}
};

int main() {
	Solution solu;
	solu.acm();
}
