# C++开发岗基础知识整理
## 目录

- [C++基础](https://github.com/GaoKangYu/Sword-For-Offer/tree/main/Again%20and%20Again#c%E5%9F%BA%E7%A1%80)

- [计算机网络](https://github.com/GaoKangYu/Sword-For-Offer/tree/main/Again%20and%20Again#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C)

- [算法与数据结构](https://github.com/GaoKangYu/Sword-For-Offer/tree/main/Again%20and%20Again#%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)

- [设计模式](https://github.com/GaoKangYu/Sword-For-Offer/tree/main/Again%20and%20Again#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F)

- [项目相关](https://github.com/GaoKangYu/Sword-For-Offer/blob/main/Again%20and%20Again/README.md#%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3)


## C++基础

### 1、什么是多态？

答：多态是指在有继承关系的不同类对象间，调用同一函数，产生了不同行为的现象。该机制通过指针（引用）和虚函数实现。

#### 1.1、如何实现多态？

答：

首先，实现多态有两个限制条件：

（1）调用函数的对象必须是指针或者引用。

（2）被调用的函数必须是虚函数，且完成了虚函数的重写。

如果调用函数的对象不是指针或者引用，那么为静态绑定，在编译阶段完成。否则为动态绑定，在运行阶段完成。

如果调用函数不是虚函数，那么都将执行基类的函数。

```C++
#include <iostream>
#include <vector>

using namespace std;

class _base{
public:
	_base() {
		cout << "构造了一个_base类" << endl;
	}

	virtual void show_name() {
		cout << "此为_base类函数" << endl;
	}

	virtual ~_base(){
		cout << "析构了一个_base类" << endl;
	}
private:
	int _m_val;

};

class _child_a : public _base {
public:
	_child_a() {
		_m_ptr = new int(0);
		cout << "构造了一个_child_a类" << endl;
	}

	void show_name() {
		cout << "此为_child_a类函数" << endl;
	}

	~_child_a() {
		cout << "析构了一个_child_a类" << endl;
		delete _m_ptr;
		cout << "释放了_m_ptr" << endl;
	}
private:
	int _m_val;
	int* _m_ptr = nullptr;
};

int main() {
	_base* _b_ptr = new _child_a;
	_b_ptr->show_name();
	delete _b_ptr;
}
```
#### 1.2、只有动态绑定才具有多态性吗？

答：静态绑定也有多态性，函数重载和运算符重载就属于编译时的静态多态性。

#### 1.3、什么是函数重载？

答：函数重载发生在同一作用域内，指一系列函数名相同但参数列表不同（类型、个数或者顺序，当然这个顺序变换不能有歧义）的函数。

#### 1.4、什么是虚函数？

答：有virtual关键字修饰的函数为虚函数，通常用于具有继承关系的类之间的函数重写。

#### 1.5、什么是函数重写？

答：函数重写发生在不同作用域间，分为虚函数重写和普通函数重写。虚函数重写用于实现多态，要求父类被重写函数有virtual关键字修饰，子类重写函数的函数名、返回类型、参数列表完全相同，不能有static。普通函数重写是重定义的一种形式。

#### 1.6、那重定义和重写有什么区别吗？

答：重定义也叫隐藏，是指子类定义了和父类函数名相同的函数（只关注函数名，返回值和参数列表无关）后，父类中的同名函数被隐藏的现象，但是可以用类作用域符号直接访问被隐藏的成员。

#### 1.7、什么是虚表？介绍一下虚函数调用过程。

答：具有虚函数的类会存在虚表，虚表是依赖于类的，类的对象共享一个虚表，虚表中存储着该类虚函数的函数指针。当创建一个该类的对象时，不同这个对象会有一块额外的空间，存放一个虚表指针，这个指针指向虚函数表，本质上是一个函数指针数组，当使用这个对象调用虚函数时，会首先通过虚表指针找到虚表，再在虚表上找到最佳匹配函数的函数指针，随后调用该函数指针指向的函数，完成调用过程。

#### 1.8、子类虚表与父类虚表的关系？

答：存在覆盖的关系，首先，子类和父类的虚表指针是不同的，如果子类没有重写父类的任一个虚函数，那么子类虚表指针指向的函数指针数组中存放的地址和父类虚表是一致的，重写哪个函数，就用子类重写的函数地址去覆盖对应位置的函数，如果子类自己新增虚函数则直接添加在虚表后面。

#### 1.9、为什么基类的析构函数必须是虚函数？

答：因为会造成内存泄露问题，当通过基类指针来管理派生类，如果析构函数不是虚函数，释放该指针时只会析构基类，导致派生类占用的空间没有被释放。

#### 1.10、介绍一下static？

答：static为静态声明符，可以用于修饰变量和函数。

对于普通变量来说，static变量具有全局生命周期，只会被初始化一次，直到整个程序结束，此外，static还具有隐藏的作用，加了可以避免命名冲突也可以避免被其他文件使用。

对于普通函数来说，static主要起隐藏的作用，默认的函数是extern，加了可以避免命名冲突也可以避免被其他文件使用。

对于类成员变量和成员函数来说，加了static后的成员将不依赖与具体对象，而是依赖于类，在类的对象创建之前就存在，可以直接通过类作用域符调用。此外，静态成员变量需要在类外初始化；静态成员函数不能访问普通成员变量，只能访问静态成员变量，造成这个现象的原因在于静态成员函数内部没有this指针。

### 2、介绍一下智能指针？

答：C++的资源管理机制主要是在构造函数申请空间，析构函数释放空间。智能指针主要用于管理在堆上分配的内存，它将普通的指针封装为一个栈对象。当栈对象的生存周期结束后，会在析构函数中释放掉申请的内存，从而防止内存泄漏。

auto_ptr：在c++11标准中被废除，使用unique_ptr代替，功能相同且安全性提升（没有浅拷贝，浅拷贝容易导致重复删除问题），增加了delete析构特性和对数组的支持。对象出了类的作用域自动析构，通过这一有限的机制，这个类模板将一个指针保存在auto_ptr对象中，拥有这个指针的所有权，当对象析构时，会在析构函数中自动的调用delete，释放保存的指针。正因如此，不能有两个auto_ptr对象拥有同一指针，因为可能在某个时机两者都会尝试析构这个内部指针。两个auto_ptr对象之间发生赋值（例如作为实参通过值拷贝传参给函数）操作时，内部指针所属权会发生改变，赋值的右者对象会丧失所有权，被设为null指针。

shared_ptr：采用引用计数的方法，多个智能指针可以指向相同对象，记录当前内存资源被多少个智能指针引用。该引用计数的内存在堆上分配。当新增一个时引用计数加1，当过期时引用计数减一。只有引用计数为0时，智能指针才会自动释放引用的内存资源。

unique_ptr：实现独占式拥有或严格拥有概念，只对一块资源负责，保证同一时间内只有一个智能指针可以指向该对象。对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用。没有拷贝构造函数，只有移动构造函数。

weak_ptr：用来解决shared_ptr相互引用时的死锁问题,如果说两个shared_ptr相互引用,那么这两个指针的引用计数永远不可能下降为0,资源永远不会释放。它是一种弱引用，不会增加引用计数，使得引用形不成环，最后就可以正常的释放内部的对象，不会造成内存泄漏。

#### 2.1、什么是拷贝构造？什么移动构造？

答：拷贝构造是指使用对象来初始化同类的另一个对象，它会分配一片空间并把传入对象的值复制过来，属于深拷贝。如果没有自行定义拷贝构造函数，编译器会自己生成，但是如果类是含有指针变量、有动态分配内存的情况，不可缺省（经过测试，验证了这一结论，编译通过运行错误，报错`Invalid address specified to RtlValidateHeap`）。
```C++
#include <iostream>
#include <vector>
#include <assert.h>

using namespace std;

class TestClass {
public:
	TestClass() {
		cout << "构造了一个TestClass类" << endl;
		_m_val = 0;
		int_ptr = new int(10);
		//int_ptr = &_m_val;
	}

	TestClass(int x) {
		cout << "构造了一个TestClass类" << endl;
		_m_val = x;
		int_ptr = new int(x);
		//错误，_m_val何时释放是未知的，这样的操作本身也不安全
		//int_ptr = &_m_val;
	}

	TestClass(const TestClass& obj) {
		cout << "构造了一个TestClass类" << endl;
		_m_val = obj._m_val;
		int_ptr = new int;
		*int_ptr = *obj.int_ptr;
	}

	~TestClass(){
		cout << "析构了一个TestClass类" << endl;
		assert(int_ptr != nullptr);
			delete this->int_ptr;
			cout << "释放了int_ptr指针" << endl;
	}
private:
	int _m_val;
	int* int_ptr;
};

int main() {
	TestClass a(10);
	TestClass b = a;
}
```


移动构造：同样为使用对象来初始化同类另一个对象，但是没有重新分配空间，而是将构造对象的指针指向了要拷贝对象的空间，并将拷贝对象的指针指空。对于程序执行过程中产生的临时对象，往往只用于传递数据（没有其它的用处），并且会很快会被销毁。因此在使用临时对象初始化新对象时，我们可以使用移动构造将其包含的指针成员指向的内存资源直接移给新对象所有，无需再新拷贝一份，这能提高初始化的执行效率。

#### 2.2、什么是浅拷贝？什么是深拷贝？

答：浅拷贝：只复制指向某一块内存的指针，拷贝出来的指针和原指针指向同一块内存，没有分配新空间。

深拷贝：先分配空间，再拷贝值，拷贝出来的指针和原指针指向两块不同的内存。

### 3、引用与右值引用有什么区别？

答：

左值与右值的区别：有名称的，可以获取到存储地址的，非临时的表达式即为左值，反之是右值。

`&`为左值引用，是变量的别名，必须进行初始化，占4个字节的空间，记录关联空间的地址。

`&&`为右值引用，是右值变量（可以是右值常量，但没有实际用途）的别名，主要用于移动语义和完美转发，实现减少临时对象的构造和析构达到提高效率的目的。

#### 3.1、什么是常量指针？什么是指针常量？

答：常量指针本质上是一个指针，指向一个常量，因此指针指向的空间内的值不能改变，但指针的值可以改变。

指针常量本质上是一个常量，但是指针类型，因此它本身的值不可改变，但是指向空间内的值是可以改变的。

#### 3.2、说一下const关键字？

答：const关键字可以修饰普通变量、指针变量、参数传递与返回值、类成员函数。

普通变量：表示是一个不可改变的常量值。

指针变量：分为常量指针与指针常量。

参数传递：参数为指针可以防止指针意外修改，参数为自定义类对象，通过const加引用的方式可以防止拷贝构造，提升性能。

返回值：修饰自定义类型作为返回值，此时返回的值不能作为左值使用，起到保护指针指向的内容或引用的内容不被修改的作用。

成员函数：性质变为常成员函数，该函数不能修改对象的数据成员而且不能调用非const函数，通常用于get函数，本质上是改变了this指针的类型，修改为了常量指针常量。

#### 3.3、static可以和const共用吗？

答：通常可以表示静态常量，但在修饰成员函数的时候不可以共用，因为 static 关键字修饰静态成员函数，静态成员函数不含有 this 指针，不能实例化，而const 成员函数必须具体到某一实例。

#### 3.4、什么是移动语义（move）？什么是完美转发？

答：移动语义是一种在构造对象的时候可以获取到已有的资源而不需要通过拷贝额外申请内存，通过移动而不是拷贝提升性能的方法。例如一些临时变量，一般想通过它们完成中间值的传递，移动语义可以不用额外申请空间去拷贝它们，而是通过移动构造直接将一个指针指向那块内存，随后将原始指针指空，接管资源，提升效率。

`int &&rr = std::move(lv);`

完美转发是指通过一个函数将参数继续转交给另一个函数进行处理的过程中始终保持参数原有属性（左值或右值的属性）的一种方法，通常在右值引用和模板结合的时候使用，这个时候由于发生自动类型推断（auto关键字也会发生，其中全部右值叠加为右值，其他为左值），出现了通用引用，结合`std::forward`函数可以实现完美转发。

### 4、介绍一下堆和栈？

答：

存储上的：

栈区（stack）：由编译器自动分配释放，存放函数的参数值，局部变量的值等。

堆区（heap）：一般需要手动分配释放，存放动态分配的值。

二者区别：生命周期不同，栈由编译器决定，堆需要手动分配释放，如果没有手动释放，程序结束时由系统回收；
	  申请方式不同，栈由编译器自动分配，堆需要使用new delete申请、释放；
	  底层实现不同，栈的空间是连续的，类似于数据结构里的栈，堆是类似于数据结构里的链表结构，内存上可以不连续；
	  申请空间大小不同，栈比较小，是固定的，堆取决于系统的有效虚拟内存，一般比较大；
	  内存利用率不同，栈是系统分配的，利用率高，堆的空间利用是随机的、不连续的，容易产生内存碎片；

#### 4.1、什么是内存碎片？

答：Valgrind可以用于检测内存泄露问题。

内存碎片是不可使用的空闲内存，分为内部碎片和外部碎片。

内部碎片的产生原因是：每次分配的内存必须被4或8或16整除，如果申请一块大小为43的空间，最终获取的可能是44或者48大小，因为四舍五入或者内存对齐而多余的空间叫内部碎片。

外部碎片是由于频繁申请释放空间而产生的，比如一块大小为地址为0-99，大小为100的空间，最初申请了大小为8的空间，系统分配了地址为0-7的空间分配，此时又额外申请一个大学为16的空间，系统完成地址为8-23的空间分配，如果这个时候，前面8个字节存的值不需要使用了，将其释放掉后，再申请的空间如果都大于8个字节，那么前面的8个字节因为装不下，将永远都不会再使用，造成了外部内存碎片。

#### 4.2、你刚才说堆的内存是链表式结构，那么内存是不连续的，为什么还会产生外部碎片？

答：堆上的内存是可以不连续，但不代表全都是不连续的，例如某些stl中的数据结构arry和vector，在堆上动态分配空间，是一块连续的内存。

#### 4.3、数组和vector的区别，链表和vector的区别。

答：

数组和vector都是用于存储相同类型对象的容器。

二者的主要区别在于：

1、内存中的位置：数组为内置的数据类型，存放在栈中，其内存的分配和释放完全由系统自动完成；vector存放在堆中，由STL库中的程序负责内存的分配和释放。

2、大小能否变化：数组的大小在初始化后就固定不变，而vector可以通过push_back或pop等操作进行变化。

3、初始化：数组不能将数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值；而vector可以。

4、执行效率：数组优于vector。主要原因是vector的扩容过程（vector的存储是连续空间，因此并不是直接在后面添加元素，而是有分配空间和拷贝的过程）要消耗大量的时间。

链表和vector

vector是连续存储空间，查找简单但在序列中间增删元素效率低。

链表的元素在内存中不是顺序存储的，而是通过存在元素中的指针联系到一起。查找效率低但增删简单。 

#### 4.4、C++程序中的其他存储区域？

答：可以分为栈区、堆区、全局区（静态区）、常量区、代码区。

栈区：编译器自动分配释放内存，存放函数参数值，局部变量值。stack

堆区：一般需要手动释放，存放动态分配的值。heap

全局区：存放全局变量和静态变量，初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，程序结束后由系统释放。分别是data区和bbs区。

常量区：常量字符串存放区，程序结束后系统释放。coment

代码区：存放函数体的二进制代码。code


## 计算机网络

### 1、TCP和UDP有什么区别？

答：
1.连接：TCP是面向连接的传输层协议，即传输数据之前必须先建立好连接；UDP无连接。

2.服务对象：TCP是点对点的两点间服务，即一条TCP连接只能有两个端点；UDP支持一对一，一对多，多对一，多对多的交互通信。

3.可靠性：TCP是可靠交付：无差错，不丢失，不重复，按序到达；UDP是尽最大努力交付，不保证可靠交付。

4.拥塞控制，流量控制：TCP有拥塞控制和流量控制保证数据传输的安全性；UDP没有拥塞控制，网络拥塞不会影响源主机的发送效率。

5.报文长度：TCP是动态报文长度，即TCP报文长度是根据接收方的窗口大小和当前网络拥塞情况决定的；UDP面向报文，不合并，不拆分，保留上面传下来报文的边界。

6.首部开销：TCP首部开销大，首部20个字节；UDP首部开销小，8字节。（源端口，目的端口，数据长度，校验和）

#### 1.1、视频通信你会选择用哪一种实现？

答：

TCP 是可靠的但传输速度慢，UDP 是不可靠的但传输速度快。因此在选用具体协议通信时，应该根据通信数据的要求而决定。

若通信数据完整性需让位与通信实时性，则应该选用TCP 协议（如文件传输、重要状态的更新等）；反之，则使用 UDP 协议（如视频传输、实时通信等）。

#### 1.2、为什么说TCP是可靠的而UDP是不可靠的？

#### 1.3、TCP从哪些方面来确保自身的可靠性？

## 计算机系统

### 1、进程与线程

答：

进程是拥有资源和独立运行的最小单位，也是程序执行的最小单位。

线程：进程内的一个相对独立的，可调度的执行单元，是系统独立调度和分派cpu的基本单位。由线程内核对象（操作系统用它来管理线程，存放线程统计信息）和线程堆栈（维护线程执行代码时所需要的函数参数和局部变量）组成。

在c++中，线程相关的操作在头文件"thread"中，通常写法为std::thread线程名(回调函数名)，较为常用的有join和detach函数，其中

join()函数是一个等待线程函数，主线程需等待子线程运行结束后才可以结束（期间主线程与子线程是是并行的），如果打算等待对应线程，则需要细心挑选调用join()的位置

detach()函数是子线程的分离函数，当调用该函数后，线程就被分离到后台运行，主线程不需要等待该线程结束才结束

二者的区别：

1. 线程是程序执行的最小单位，而进程是操作系统分配资源的最小单位；

2. 一个进程由一个或多个线程组成，线程是一个进程中代码的不同执行路线；

3. 进程之间相互独立，但同一进程下的各个线程之间共享程序的内存空间(包括代码段，数据集，堆等)及一些进程级的资源(如打开文件和信号等)，某进程内的线程在其他进程不可见；

4. 调度和切换：线程上下文切换比进程上下文切换要快得多；

#### 1.1、线程同步问题？

答：线程不同步是指两个线程操作同一个资源的时候造成预期外结果的现象。C++作为高级语言翻译为汇编语言的时候一行语句对应多行汇编，因为时间切片的原因可能执行到汇编的某一行的时候就切换到了另一线程。

#### 1.2、如何解决这个问题？

答：可以用锁，我使用过的是c++中的线程同步锁，在头文件<memory>中

## 算法与数据结构

### 1、快速排序的复杂度分析？口述其原理。

答：快速排序的平均时间复杂度为O（NlogN），最坏的情况下，如果基准值始终是最小元素，那么时间复杂度为O（N^2）。

原理：选取一个基准值（以最左边的值为例），用两个指针分别指向序列最左边和最右边，以增序排列为例，在左指针始终在右指针左边的前提下，右指针从最右边开始，找到一个比基准小的，随后左指针从最左边开始，找到一个比基准值大的，交换这两个值，当一次遍历结束，两个指针相遇时，基准值归位，交换基准值和左指针指向的值，随后递归左边，递归右边，重复上述操作，直到左边界与右边界相遇。


## 设计模式

## 常见编程题目

### 反转链表

```C++
#include <iostream>

using namespace std;

struct ListNode {
	int val;
	ListNode* next;
	ListNode(int x) : val(x), next(nullptr) { }
};

class Solution {
public:
	ListNode* reverseList(ListNode* head) {
		//pre cur next
		ListNode* pre = nullptr;
		ListNode* cur = head;
		while (cur) {
			ListNode* next = cur->next;
			cur->next = pre;
			pre = cur;
			cur = next;
		}
		return pre;
	}
};

int main() {
	Solution solu;
	ListNode* head = new ListNode(1);
	ListNode* node_1 = new ListNode(2);
	ListNode* node_2 = new ListNode(3);

	head->next = node_1;
	node_1->next = node_2;

	ListNode* res = solu.reverseList(head);
	while (res){
		cout << res->val << " ";
		res = res->next;
	}
}
```

## 项目相关
